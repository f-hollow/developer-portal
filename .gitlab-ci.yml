stages:
  # - build
  # - deploy
  # - comment
  - sync_merge

sync_merge_to_github:
  stage: sync_merge
  image: debian:latest
  tags:
    - deploy_docs
    - shiny
  rules:
    - if: '$CI_MERGE_REQUEST_LABELS =~ /GitHub-Sync-Merge/'
    #   when: always
    # - when: never
  script:
    #- echo "The sync_merge_to_github job was triggered!"
    - apt-get update && apt-get install -y git gh
    - export SOURCE_BRANCH="${CI_MERGE_REQUEST_SOURCE_BRANCH_NAME}"
    - export GITHUB_REPO="f-hollow/developer-portal"

    # Configure Git
    - git config --global user.email "developer.portal.bot@example.com"
    - git config --global user.name "Developer-Portal-BOT"

    # Clone the repository
    - git clone "$CI_REPOSITORY_URL" repo
    - cd repo
    # Checkout the feature branch
    - git checkout "$SOURCE_BRANCH"
    # Ensure main is up to date
    - git fetch origin main
    # Rebase the feature branch on main
    - git rebase main
    # Add GitHub remote
    - git remote add github "https://oauth2:${GITHUB_ACCESS_TOKEN}@github.com/${GITHUB_REPO}.git"
    # Push the rebased branch to GitHub
    # - git push -u --force-with-lease github "$SOURCE_BRANCH"
    - git push -u -f github "$SOURCE_BRANCH"

    # Wait for GitHub to register the branch
    - sleep 5

    # Create a PR on GitHub
    # - echo "$GITHUB_ACCESS_TOKEN" | gh auth login --with-token
    - export GITHUB_TOKEN="$GITHUB_ACCESS_TOKEN"
    - |
      gh pr create \
        --repo "$GITHUB_REPO" \
        --head "$SOURCE_BRANCH" \
        --base main \
        --title "Sync Merge: ${SOURCE_BRANCH}" \
        --body "This PR syncs the GitLab branch ${SOURCE_BRANCH} to GitHub."

# build_hugo:
#   stage: build
#   image: "${CI_TEMPLATE_REGISTRY_HOST}/pages/hugo/hugo_extended:0.135.0"
#   tags:
#     - build_docs
#   rules:
#     - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
#   variables:
#     GIT_SUBMODULE_STRATEGY: recursive
#     NAME: "${CI_COMMIT_REF_SLUG}"
#   script:
#     - hugo --gc --minify --environment staging --baseURL "${DOCS_PREVIEW_URL_BASE}/${NAME}"
#     # use branch name like directory name for the URL path going forward
#     - mv -v public "${NAME}"
#     - tar -czf archive.tar.gz "${NAME}"
#   artifacts:
#     paths:
#       - archive.tar.gz
#     expire_in: 1 week

# deploy_preview_hugo:
#   stage: deploy
#   image: espressif/scp
#   tags:
#     - deploy_docs
#     - shiny
#   rules:
#     - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
#   needs: ["build_hugo"]
#   variables:
#     SSH_KEY: "$DOCS_PREVIEW_PRIVATEKEY" # SSH_KEY used inside espressif/scp
#     SERVER_PATH: "$DOCS_PREVIEW_PATH"
#     SERVER_URL_BASE: "$DOCS_PREVIEW_URL_BASE"
#     USER: "$DOCS_PREVIEW_SERVER_USER"
#     SERVER: "$DOCS_PREVIEW_SERVER"
#     NAME: "${CI_COMMIT_REF_SLUG}"
#   script:
#     # upload and extract the archive,
#     # delete the old directory with the same name (if doesn't contain . or /)
#     # so as not to accumulate garbage from the previous run
#     - cat archive.tar.gz | ssh ${USER}@${SERVER}
#         "cd ${SERVER_PATH};
#         [[ \"$NAME\" != *.* && \"$NAME\" != */* ]] && [ -d \"$NAME\" ] && rm -rf \"$NAME\";
#         pwd; tar xzvf -"
#     - echo "Preview ${SERVER_URL_BASE}/${NAME}"

# post_preview_link:
#   stage: comment
#   image: badouralix/curl-jq
#   tags:
#     - deploy_docs
#     - shiny
#   rules:
#     - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
#   needs: ["deploy_preview_hugo"]
#   variables:
#     SERVER_URL_BASE: "$DOCS_PREVIEW_URL_BASE"
#     NAME: "${CI_COMMIT_REF_SLUG}"
#     MR_ID: "$CI_MERGE_REQUEST_IID"
#     PROJECT_ID: "$CI_MERGE_REQUEST_PROJECT_ID"
#   script:
#     - |
#       # Print MR_ID and PROJECT_ID for debugging
#       echo "MR_ID: ${MR_ID}"
#       echo "PROJECT_ID: ${PROJECT_ID}"
#       echo "$CI_SERVER_HOST"
#       echo "${CI_SERVER_PORT}"

#       GITLAB_API="https://${CI_SERVER_HOST}:${CI_SERVER_PORT}/api/v4/projects/${PROJECT_ID}/merge_requests/${MR_ID}/notes"
#       AUTH_HEADER="PRIVATE-TOKEN: ${GITLAB_BOT_API_TOKEN}"

#       # Get existing comments
#       API_RESPONSE=$(curl --silent --header "$AUTH_HEADER" "$GITLAB_API")
#       echo "API Response: $API_RESPONSE"  # Add this line for debugging

#       # Check if the response contains the expected structure
#       COMMENTS=$(echo "$API_RESPONSE" | jq -r '.[] | select(.body | contains("ðŸŽ‰ Preview for this MR")) | .id')

#       # Delete previous preview comments
#       if [ -n "$COMMENTS" ]; then
#         for COMMENT_ID in $COMMENTS; do
#           curl --silent --request DELETE --header "$AUTH_HEADER" "${GITLAB_API}/${COMMENT_ID}"
#         done
#       fi

#       # Post new preview link
#       PREVIEW_LINK="${SERVER_URL_BASE}/${NAME}"
#       COMMENT_BODY="ðŸŽ‰ Preview for this MR: ${PREVIEW_LINK}"
#       curl --silent --request POST --header "$AUTH_HEADER" --header "Content-Type: application/json" \
#         --data "{\"body\": \"${COMMENT_BODY}\"}" "$GITLAB_API"
